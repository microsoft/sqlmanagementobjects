// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using Microsoft.SqlServer.Management.Sdk.Sfc;
using Microsoft.SqlServer.Management.Sdk.Sfc.Metadata;
using Cmn = Microsoft.SqlServer.Management.Common;

namespace Microsoft.SqlServer.Management.Smo
{
    /// <summary>
    /// This class represents an Edge Constraint
    /// object. Edge Constraints restrict connections
    /// that can be established in an edge table between
    /// two graph nodes. Edge Constraints are creatable
    /// and droppable but not alterable. For altering the original
    /// must be dropped and new one must be created.
    /// </summary>
    public partial class EdgeConstraint : ScriptNameObjectBase, Cmn.ICreatable, Cmn.IDroppable, Cmn.IDropIfExists, Cmn.IRenamable, Cmn.IMarkForDrop, IScriptable
    {
        // Constant string for EdgeConstrait URN.
        //
        private const string EDGE_CONSTRAINT_URN = "EdgeConstraint";

        // String property identifier for 'DeleteAction'
        //
        private const string DELETE_ACTION = "DeleteAction";

        /// <summary>
        /// Constructor for instantiating Edge Constraint object. Also initializes encapsulated clauses.
        /// </summary>
        /// <param name="parentColl">Parent object that encapsulates this object (Edge tables in this case) </param>
        /// <param name="key">key that identifies the object in collection</param>
        /// <param name="state">current state of the object represented by enumerator <see cref="SqlSmoState"/></param>
        internal EdgeConstraint(AbstractCollectionBase parentColl, ObjectKeyBase key, SqlSmoState state) :
            base(parentColl, key, state)
        {
            m_EdgeConstraintClauses = null;
        }

        private EdgeConstraintClauseCollection m_EdgeConstraintClauses;
        /// <summary>
        /// This method instantiates EdgeConstraintClause collection. An EdgeConstraint object 
        /// can encapsulate multiple EdgeConstraintClauses within it.
        /// </summary>
        [SfcObject(SfcContainerRelationship.ChildContainer, SfcContainerCardinality.ZeroToAny, typeof(EdgeConstraintClause), SfcObjectFlags.Design)]
        public EdgeConstraintClauseCollection EdgeConstraintClauses
        {
            get
            {
                CheckObjectState();
                if (null == m_EdgeConstraintClauses)
                {
                    m_EdgeConstraintClauses = new EdgeConstraintClauseCollection(this);
                }

                return m_EdgeConstraintClauses;
            }
        }

        /// <summary>
        /// Accessor for URN suffix for Edge Constraint object.
        /// </summary>
        /// <returns> the name of the type in the urn expression </returns>
        public static string UrnSuffix
        {
            get
            {
                return EDGE_CONSTRAINT_URN;
            }
        }

        /// <summary>
        /// Accessor for the object name.
        /// </summary>
        [SfcKey(0)]
        [SfcProperty(SfcPropertyFlags.ReadOnlyAfterCreation | SfcPropertyFlags.Design | SfcPropertyFlags.SqlAzureDatabase | SfcPropertyFlags.Standalone)]
        public override string Name
        {
            get
            {
                // It is possible that if the state of this object is still 'Creating' and the
                // user has not provided a name initially then a system name is yet to be generated. Therefore
                // during a state check if we encounter a 'Creating' state a null reference is returned.
                //
                return (IsDesignMode && GetIsSystemNamed() && this.State == SqlSmoState.Creating) ? null : base.Name;
            }
            set
            {
                base.Name = value;
                if (ParentColl != null)
                {
                    SetIsSystemNamed(false);
                }
            }
        }

        /// <summary>
        /// Accessor for the property 'IsSystemNamed' for this edge-constraint object.
        /// </summary>
        [SfcProperty(SfcPropertyFlags.SqlAzureDatabase | SfcPropertyFlags.Standalone)]
        public System.Boolean IsSystemNamed
        {
            get
            {
                // A non-existing object should not have the 'IsSytemNamed' property yet.
                // Names are either provided by the user (key) or generated by the system
                // at time of object creation.
                //
                if (ParentColl != null && IsDesignMode && this.State != SqlSmoState.Existing)
                {
                    throw new PropertyNotSetException("IsSystemNamed");
                }
                return (bool)this.Properties.GetValueWithNullReplacement("IsSystemNamed");
            }
        }

        /// <summary>
        /// Override for UpdateObjectState method. The method generates a system name
        /// if the user does not provide a name while creating the object otherwise
        /// it uses the name provided by the user and sets 'IsSystemNamed' property to false.
        /// </summary>
        internal override void UpdateObjectState()
        {
            if (this.State == SqlSmoState.Pending && null != this.ParentColl && (!key.IsNull || IsDesignMode))
            {
                SetState(SqlSmoState.Creating);
                if (key.IsNull)
                {
                    AutoGenerateName();
                }
                else
                {
                    SetIsSystemNamed(false);
                }
            }
        }

        /// <summary>
        /// Utility method to create DDL statement for this object.
        /// </summary>
        /// <returns></returns>
        public StringCollection Script()
        {
            return ScriptImpl();
        }

        /// <summary>
        /// Utility method to create DDL statements for this object
        /// by passing additional scripting options as arguments.
        /// </summary>
        /// <param name="scriptingOptions">
        ///     Instance of <see cref="ScriptingOptions"/> that encapsulates SQL Server scripting preferences
        /// </param>
        /// <returns><see cref="StringCollection"/> wrapping associated SQL scripts for this object</returns>
        public StringCollection Script(ScriptingOptions scriptingOptions)
        {
            return ScriptImpl(scriptingOptions);
        }

        /// <summary>
        /// Method to create the Edge Constraint object.
        /// </summary>
        public void Create()
        {
            ThrowIfParentIsNotEdgeTable();
            base.CreateImpl();
        }

        /// <summary>
        /// This method includes the DDL statement required to create Edge Constraint
        /// object in the query collection reference.
        /// </summary>
        /// <param name="queries">Collection of existing queries on this object</param>
        /// <param name="sp">Additional options that control scripting behavior</param>
        internal override void ScriptCreate(StringCollection queries, ScriptingPreferences sp)
        {
            ThrowIfParentIsNotEdgeTable();
            this.ThrowIfNotSupported(this.GetType(), sp);
            queries.Add(ScriptWithOption(sp, ScriptFlag.CREATE));
        }

        /// <summary>
        /// This method generates the DDL scripts required to drop or create edge constraint
        /// based upon the passed option flag.
        /// </summary>
        /// <param name="sp">Additional options that control scripting behavior</param>
        /// <param name="option">option to include either the DROP or CREATE script</param>
        /// <returns></returns>
        internal string ScriptWithOption(ScriptingPreferences sp, ScriptFlag option)
        {
            if (option == ScriptFlag.DROP)
            {
                return string.Format(SmoApplication.DefaultCulture, "ALTER TABLE {0} DROP CONSTRAINT {1}", this.Parent.FullQualifiedName, this.FullQualifiedName);
            }
            else
            {
                return string.Format(SmoApplication.DefaultCulture, "ALTER TABLE {0} ADD{1}", this.Parent.FullQualifiedName, ScriptDdlBodyWorker(sp, true));
            }
        }

        /// <summary>
        /// This method is presently being leveraged by Table objects to have the DDL script
        /// of EdgeConstraints included within their definition. When a user invokes script
        /// option on an EdgeTable that has EdgeConstraint encapsulated within it the Table object
        /// would call this method to have the scripts of such nested objects included along 
        /// with its own DDL script.
        /// </summary>
        internal String ScriptDdlBody(ScriptingPreferences sp)
        {
            ThrowIfParentIsNotEdgeTable();
            return ScriptDdlBodyWorker(sp);
        }

        /// <summary>
        /// EdgeConstraint(s) support 'ON DELETE CASCADE' clause which affect referenced records in an edge
        /// table when linked records in connected nodes are dropped. While scripting, this method ensures
        /// that if the object supports the cascade delete option then it is included as a part of scripting via SMO.
        /// </summary>
        /// <returns>
        /// String value containing information about referential action to be taken for the EdgeConstraint object.
        /// </returns>
        private string ScriptDeleteReferentialAction()
        {
            EdgeConstraintDeleteAction ecDeleteAction = this.GetPropValueOptional<EdgeConstraintDeleteAction>(DELETE_ACTION, EdgeConstraintDeleteAction.NoAction);
            switch (ecDeleteAction)
            {
                case EdgeConstraintDeleteAction.NoAction:
                    return string.Empty;
                case EdgeConstraintDeleteAction.Cascade:
                    return " ON DELETE CASCADE";
                default:
                    throw new InvalidSmoOperationException(ExceptionTemplates.InvalidEdgeConstraintReferentialAction(ecDeleteAction.ToString()));
            }
        }

        /// <summary>
        /// This method is used during scripting of the EdgeConstraint object, it ensures that
        /// all connections that the EdgeConstraint parent object encapsulates are included while scripting.
        /// </summary>
        private String ScriptDdlBodyWorker(ScriptingPreferences sp, bool withConstraintName = true)
        {
            CheckObjectState();

            // EdgeConstraint(s) should have atleast one encapsulated clause. Checking this condition and bubbling
            // up an Exception if they have none at the time of scripting. Since this is also handled by sql server
            // at the time of object creation this check is more of a revalidation.
            //
            if (this.EdgeConstraintClauses.Count < 1)
            {
                throw new InvalidSmoOperationException(ExceptionTemplates.InvalidEdgeConstraintDefinition);
            }

            StringBuilder sb = new StringBuilder(Globals.INIT_BUFFER_SIZE);
            AddConstraintName(sb, sp);
            String clauses = ScriptEdgeConstraintClauses();
            sb.AppendFormat(SmoApplication.DefaultCulture, "CONNECTION ({0})", clauses);
            sb.Append(this.ScriptDeleteReferentialAction());

            return sb.ToString();
        }

        /// <summary>
        /// This method iterates over all clauses that this Edge Constraint object
        /// encapsulates and returns them as a String.
        /// </summary>
        /// <returns>All connections this edge encapsulates represented as a string</returns>
        private String ScriptEdgeConstraintClauses()
        {
            return string.Join(",",
                 from EdgeConstraintClause clause in this.EdgeConstraintClauses
                 let fromSchemaMaybe = clause.GetPropValueOptional(nameof(EdgeConstraintClause.FromSchema))
                 let toSchemaMaybe = clause.GetPropValueOptional(nameof(EdgeConstraintClause.ToSchema))
                 let fromSchema = (fromSchemaMaybe != null) ? MakeSqlBraket(fromSchemaMaybe.ToString()) + "." : string.Empty
                 let toSchema = (toSchemaMaybe != null) ? MakeSqlBraket(toSchemaMaybe.ToString()) + "." : string.Empty
                 select $"{fromSchema}{MakeSqlBraket(clause.From)} To {toSchema}{MakeSqlBraket(clause.To)}");
        }

        /// <summary>
        /// Renames the object.
        /// </summary>
        /// <param name="newName">New Edge Constraint name</param>
        public void Rename(string newName)
        {
            if (string.IsNullOrEmpty(newName))
            {
                throw new InvalidSmoOperationException(ExceptionTemplates.EmptyConstraintName);
            }

            base.RenameImpl(newName);
        }

        /// <summary>
        /// Method that handles the generation of rename script for this object.
        /// </summary>
        /// <param name="renameQuery">Query collection on which the rename script would be included</param>
        /// <param name="sp">Additional options that control scripting behavior</param>
        /// <param name="newName">new name for the object</param>
        internal override void ScriptRename(StringCollection renameQuery, ScriptingPreferences sp, string newName)
        {
            this.ThrowIfNotSupported(this.GetType(), sp);

            renameQuery.Add(string.Format(SmoApplication.DefaultCulture,
                                "EXEC {0}.dbo.sp_rename @objname = N'{1}.{2}', @newname = N'{3}', @objtype = N'OBJECT'",
                                MakeSqlBraket(GetDBName()),
                                SqlString(MakeSqlBraket(((ScriptSchemaObjectBase)this.ParentColl.ParentInstance).Schema)),
                                SqlString(this.FullQualifiedName),
                                SqlString(newName)));
        }

        /// <summary>
        /// Calls the base class' drop implementation to remove this instance of EdgeConstraint.
        /// </summary>
        public void Drop()
        {
            base.DropImpl();
        }

        /// <summary>
        /// Short circuit logic to check if parent table is an edge table. As EdgeConstraints
        /// are only supported on Edge tables and UDTTs.
        /// </summary>
        private void ThrowIfParentIsNotEdgeTable()
        {
            Table parentTable = this.Parent as Table;
            if (parentTable == null || !parentTable.IsEdge)
            {
                throw new InvalidSmoOperationException(ExceptionTemplates.InvalidEdgeConstraintParent);
            }
        }

        /// <summary>
        /// Drops the object with IF EXISTS option.
        /// </summary>
        public void DropIfExists()
        {
            base.DropImpl(true);
        }

        /// <summary>
        /// Method that handles the generation of drop script for this object.
        /// </summary>
        /// <param name="queries">Query collection on which the drop script would be included</param>
        /// <param name="sp">Additional options that control scripting behavior</param>
        internal override void ScriptDrop(StringCollection queries, ScriptingPreferences sp)
        {
            this.ThrowIfNotSupported(this.GetType(), sp);

            CheckObjectState();

            StringBuilder sb = new StringBuilder(Globals.INIT_BUFFER_SIZE);
            bool isTargetServerVersionSQl13OrLater = VersionUtils.IsTargetServerVersionSQl13OrLater(sp.TargetServerVersion);
            if (sp.IncludeScripts.ExistenceCheck)
            {
                TableViewBase table = (TableViewBase)ParentColl.ParentInstance;
                string sTableName = table.FormatFullNameForScripting(sp);

                // Constraints are dropped before tables are dropped in scripts generated for Transfer
                // Therefore we always check for table existence.
                sb.AppendFormat(SmoApplication.DefaultCulture, Scripts.INCLUDE_EXISTS_TABLE90, string.Empty, SqlString(sTableName));                
                sb.Append(sp.NewLine);
            }

            sb.AppendFormat(SmoApplication.DefaultCulture,
                            "ALTER TABLE {0} DROP CONSTRAINT {1}{2}",
                            ((ScriptSchemaObjectBase)ParentColl.ParentInstance).FormatFullNameForScripting(sp),
                            sp.IncludeScripts.ExistenceCheck ? "IF EXISTS " : string.Empty,
                            FormatFullNameForScripting(sp));

            queries.Add(sb.ToString());
        }

        /// <summary>
        /// Calls base parent class' implementation for MarkForDrop. The base class'
        /// method marks the state for the object for deletion. Represented by
        /// 'ToBeDropped' state of the enumerator <see cref="SqlSmoState"/>
        /// </summary>
        /// <param name="dropOnAlter"></param>
        public void MarkForDrop(bool dropOnAlter)
        {
            base.MarkForDropImpl(dropOnAlter);
        }

        /// <summary>
        /// Returns the fields that will be needed to script this object.
        /// </summary>
        /// <param name="parentType">The type of the parent object</param>
        /// <param name="version">The version of the server</param>
        /// <param name="databaseEngineType">The database engine type of the server</param>
        /// <param name="databaseEngineEdition">The database engine edition of the server</param>
        /// <param name="defaultTextMode">indicates the text mode of the server.
        /// If true this means only header and body are needed, otherwise all properties</param>
        /// <returns></returns>
        internal static string[] GetScriptFields(Type parentType,
            Cmn.ServerVersion version,
            Cmn.DatabaseEngineType databaseEngineType,
            Cmn.DatabaseEngineEdition databaseEngineEdition,
            bool defaultTextMode)
        {
            string[] fields = {DELETE_ACTION, "IsSystemNamed"};
            List<string> list = GetSupportedScriptFields(typeof(EdgeConstraint.PropertyMetadataProvider), fields, version, databaseEngineType, databaseEngineEdition);
            return list.ToArray();
        }
    }
}