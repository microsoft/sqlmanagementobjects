 ///////////////////////////////////////////////////////////////
 //
 // WARNING : DO NOT ATTEMPT TO MODIFY THIS FILE MANUALLY
 // 
 // This class is autogenerated from WmiCollectionTemplate.cs
 //
 ///////////////////////////////////////////////////////////////

using System;
using System.Collections;

#include "coll_macros.h"

namespace NAMESPACE_NAME
{

	///<summary>
	/// Strongly typed list of MAPPED_TYPE objects
	/// Has strongly typed support for all of the methods of the sorted list class
	///</summary>
	public SEALED_IMP class TOKEN_PASTE( MAPPED_TYPE, COLLECTION_SUFFIX) : WmiCollectionBase, ICollection 
	{

		internal TOKEN_PASTE( MAPPED_TYPE, COLLECTION_SUFFIX)(WmiSmoObject parentInstance)  : base(parentInstance)
		{
		}

#ifdef PARENT
		public PARENT Parent
		{
			get
			{
				return this.ParentInstance as PARENT;
			}
		}
#endif
		
		// checks if the collection contains the specified key
		// if the key is not found, we try to look for the specified object on the server
		public bool Contains(KEY_TYPE key) 
		{ 
			if(innerColl.ContainsKey(key))
			{
				return true;
			}
			else
			{
				if(!initialized )
				{
					// try to get the child object, if any
					if(null!=InitializeChildObject(key))
						return true;
				}
			}

			// in all other cases we don't have this object
			return false;
		}

		
		public MAPPED_TYPE this[Int32 index]
		{
			get
			{ 
				return GetObjectByIndex(index);
			}
		}

		// returns wrapped object
		internal MAPPED_TYPE GetObjectByIndex(Int32 index)
		{
			if(!initialized)
				InitializeChildCollection();
			
			return innerColl.GetByIndex(index) as MAPPED_TYPE;
		}
		
		// returns wrapper class
		public MAPPED_TYPE this[KEY_TYPE name]
		{
			get
			{
				return  GetObjectByName(name);
			}
		}

		// returns wrapped object
		internal MAPPED_TYPE GetObjectByName(string name)
		{
			object instanceObject = innerColl[name];
			
			if( null==instanceObject && !initialized  )
			{
				instanceObject = InitializeChildObject(name);
			}
			
			return instanceObject as MAPPED_TYPE;
		}

#ifdef SERVER_PROTOCOL
		protected sealed override void Add(WmiSmoObject wmiObj) 
		{
			innerColl.Add(wmiObj.Name, wmiObj);
		}

		protected sealed override void Remove(string objname)
		{
			throw new NotImplementedException();
		}
#endif
	
		// this function tries to instantiate a missing object
		// and if it exists we add it to the innerColl
		internal object InitializeChildObject(string name)
		{
			// we create a new object
			MAPPED_TYPE childobj = new MAPPED_TYPE(this, name);
			
			if(childobj.Initialize())
			{
				// update object's state and add it to the collection
				this.Add(childobj);
				return childobj;
			}
			else
			{
				return null;
			}
		}

		//Initializes the child collection, keeping all the old objects
		// TODO: Make sure we add thread safety stuff, at least here 
		// since we are changing the underlying collection
		internal void InitializeChildCollection()
		{
			// keep the old collection, because we'll append all the objects to the new one
			SortedList oldColl = innerColl;
			innerColl = new SortedList();

			// populate the new collection, calling into parent's function
			ParentInstance.EnumChildren(typeof(MAPPED_TYPE).ToString(), this);

			// now merge the old collection into the new one
			foreach(DictionaryEntry de in oldColl)
			{
				MAPPED_TYPE objMAPPED_TYPE = de.Value as MAPPED_TYPE;
				
				// this asssignment has the effect of adding new members to the collection
				// and of replacing the existing ones with the old values
				innerColl[objMAPPED_TYPE.Name] = objMAPPED_TYPE;
			}

			// update the state flag
			this.initialized = true;
		}

		public Int32 Count 
		{ 
			get 
			{
				if(!initialized )
					InitializeChildCollection();
				return innerColl.Count;
			} 
		}

		public void CopyTo(MAPPED_TYPE[] array, Int32 index)
		{
			((ICollection)this).CopyTo(array, index);
		}

		void ICollection.CopyTo(Array array, Int32 index)
		{
			if(!initialized)
				InitializeChildCollection();

			int idx = index;
			foreach(DictionaryEntry de in innerColl)
			{
				array.SetValue( (MAPPED_TYPE)de.Value, idx++);
			}
		}

		public IEnumerator  GetEnumerator() 
		{
			if(!initialized)
				InitializeChildCollection();
			return new TOKEN_PASTE(MAPPED_TYPE, CollectionEnumerator)(this);
		}


		// nested enumerator class
		// we need that to override the behaviour of SortedList
		// that exposes an IDictionaryEnumerator interface
		internal sealed class TOKEN_PASTE(MAPPED_TYPE, CollectionEnumerator) : IEnumerator 
		{
			internal IDictionaryEnumerator baseEnumerator;
			
			internal TOKEN_PASTE(MAPPED_TYPE, CollectionEnumerator)(WmiCollectionBase col) 
			{
				this.baseEnumerator = col.innerColl.GetEnumerator();
			}

			object IEnumerator.Current 
			{ 
				get 
				{	
					return baseEnumerator.Value as MAPPED_TYPE;
				} 
			}
			
			public MAPPED_TYPE Current 
			{ 
				get 
				{	
					return baseEnumerator.Value as MAPPED_TYPE;
				} 
			}
			
			public bool MoveNext() 
			{
				return baseEnumerator.MoveNext();
			}
			
			public void Reset() 
			{
				baseEnumerator.Reset();
			}

		}

	}
}

